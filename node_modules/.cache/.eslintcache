[{"/home/alynux/GitHub/fifteen-puzzle/src/index.js":"1","/home/alynux/GitHub/fifteen-puzzle/src/App.js":"2","/home/alynux/GitHub/fifteen-puzzle/src/classes/game.js":"3","/home/alynux/GitHub/fifteen-puzzle/src/classes/tile.js":"4","/home/alynux/GitHub/fifteen-puzzle/src/classes/board.js":"5","/home/alynux/GitHub/fifteen-puzzle/src/components/Game.tsx":"6","/home/alynux/GitHub/fifteen-puzzle/src/components/Grid.tsx":"7","/home/alynux/GitHub/fifteen-puzzle/src/components/GridRow.tsx":"8","/home/alynux/GitHub/fifteen-puzzle/src/components/GridSquare.tsx":"9"},{"size":197,"mtime":1643223210885,"results":"10","hashOfConfig":"11"},{"size":129,"mtime":1643249916342,"results":"12","hashOfConfig":"11"},{"size":284,"mtime":1643248157773,"results":"13","hashOfConfig":"11"},{"size":1217,"mtime":1643254766067,"results":"14","hashOfConfig":"11"},{"size":8598,"mtime":1643254993281,"results":"15","hashOfConfig":"11"},{"size":987,"mtime":1643252056305,"results":"16","hashOfConfig":"11"},{"size":1766,"mtime":1643249884930,"results":"17","hashOfConfig":"11"},{"size":673,"mtime":1643250006279,"results":"18","hashOfConfig":"11"},{"size":2598,"mtime":1643255221346,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"1mgkcpz",{"filePath":"23","messages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"27","messages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31"},{"filePath":"32","messages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40"},"/home/alynux/GitHub/fifteen-puzzle/src/index.js",[],["41","42"],"/home/alynux/GitHub/fifteen-puzzle/src/App.js",[],"/home/alynux/GitHub/fifteen-puzzle/src/classes/game.js",[],"/home/alynux/GitHub/fifteen-puzzle/src/classes/tile.js",[],"/home/alynux/GitHub/fifteen-puzzle/src/classes/board.js",["43","44"],"import TileObject from \"./tile\";\n\nexport default class BoardObject {\n  constructor() {\n    this.boardState = [\n      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    ].flatMap((i) => new TileObject(i, i));\n  }\n\n  // Fisher-Yates shuffle algorithm\n  scrambleTiles() {\n    const boardTiles = [...this.boardState];\n    let currentIndex = boardTiles.length,\n      placeholderTile,\n      randomIndex;\n\n    // While elements exist to shuffle\n    while (currentIndex != 0) {\n      randomIndex = Math.floor(Math.random() * currentIndex--);\n\n      // Change board tile indeces\n      boardTiles[currentIndex].setPosition(randomIndex);\n      boardTiles[randomIndex].setPosition(currentIndex);\n\n      // Swap board tile positions in boardState list\n      placeholderTile = boardTiles[currentIndex];\n      boardTiles[currentIndex] = boardTiles[randomIndex];\n      boardTiles[randomIndex] = placeholderTile;\n    }\n\n    this.boardState = boardTiles;\n  }\n\n  immediateMove(tilePressed) {\n    const emptyTile = this.boardState.find((tile) => tile.number === 0);\n    const emptyPosition = emptyTile.getPosition();\n    emptyTile.setPosition(tilePressed.position);\n    tilePressed.setPosition(emptyPosition);\n    this.setMovableTiles();\n  }\n\n  complexMove(tilePressed) {\n    const emptyTile = this.boardState.find((tile) => tile.number === 0);\n    const emptyRowNumber = emptyTile.coordinates[0];\n    const emptyColNumber = emptyTile.coordinates[1];\n    const rowNumber = tilePressed.coordinates[0];\n    const colNumber = tilePressed.coordinates[1];\n\n    if (rowNumber === emptyRowNumber) {\n      if (colNumber > emptyColNumber) {\n        const tilesToMove = this.boardState.filter(\n          (tile) =>\n            tile.columnMovable &&\n            tile.coordinates[1] > emptyColNumber &&\n            tile.coordinates[1] <= colNumber\n        );\n        const newEmptyPosition = Math.max(\n          ...tilesToMove.map((t) => t.position)\n        );\n        tilesToMove.forEach((t) => t.setPosition(t.position - 1));\n        emptyTile.setPosition(newEmptyPosition);\n      } else {\n        const tilesToMove = this.boardState.filter(\n          (tile) =>\n            tile.columnMovable &&\n            tile.coordinates[1] < emptyColNumber &&\n            tile.coordinates[1] >= colNumber\n        );\n        const newEmptyPosition = Math.min(\n          ...tilesToMove.map((t) => t.position)\n        );\n\n        tilesToMove.forEach((t) => t.setPosition(t.position + 1));\n        emptyTile.setPosition(newEmptyPosition);\n      }\n    } else {\n      if (rowNumber > emptyRowNumber) {\n        const tilesToMove = this.boardState.filter(\n          (tile) =>\n            tile.rowMovable &&\n            tile.coordinates[0] > emptyRowNumber &&\n            tile.coordinates[0] <= rowNumber\n        );\n        const newEmptyPosition = Math.max(\n          ...tilesToMove.map((t) => t.position)\n        );\n\n        tilesToMove.forEach((t) => t.setPosition(t.position - 4));\n        emptyTile.setPosition(newEmptyPosition);\n      } else {\n        const tilesToMove = this.boardState.filter(\n          (tile) =>\n            tile.rowMovable &&\n            tile.coordinates[0] < emptyRowNumber &&\n            tile.coordinates[0] >= rowNumber\n        );\n        const newEmptyPosition = Math.min(\n          ...tilesToMove.map((t) => t.position)\n        );\n        tilesToMove.forEach((t) => t.setPosition(t.position + 4));\n        emptyTile.setPosition(newEmptyPosition);\n      }\n    }\n    this.setMovableTiles();\n  }\n\n  detectMovableTiles() {\n    const boardTiles = [...this.boardState];\n    const emptyTile = boardTiles.find((tile) => tile.empty);\n    let immediateMovableTiles;\n    let columnMovableTiles;\n    let rowMovableTiles;\n\n    switch (emptyTile.position) {\n      case 0:\n        immediateMovableTiles = [1, 4];\n        columnMovableTiles = [4, 8, 12];\n        rowMovableTiles = [1, 2, 3];\n        break;\n      case 1:\n        immediateMovableTiles = [0, 2, 5];\n        columnMovableTiles = [5, 9, 13];\n        rowMovableTiles = [0, 2, 3];\n        break;\n      case 2:\n        immediateMovableTiles = [1, 3, 6];\n        columnMovableTiles = [6, 10, 14];\n        rowMovableTiles = [0, 1, 3];\n        break;\n      case 3:\n        immediateMovableTiles = [2, 7];\n        columnMovableTiles = [7, 11, 15];\n        rowMovableTiles = [0, 1, 2];\n        break;\n      case 4:\n        immediateMovableTiles = [0, 5, 8];\n        columnMovableTiles = [0, 8, 12];\n        rowMovableTiles = [5, 6, 7];\n        break;\n      case 5:\n        immediateMovableTiles = [1, 4, 6, 9];\n        columnMovableTiles = [1, 9, 13];\n        rowMovableTiles = [4, 6, 7];\n        break;\n      case 6:\n        immediateMovableTiles = [2, 5, 7, 10];\n        columnMovableTiles = [2, 10, 14];\n        rowMovableTiles = [4, 5, 7];\n        break;\n      case 7:\n        immediateMovableTiles = [3, 6, 11];\n        columnMovableTiles = [3, 11, 15];\n        rowMovableTiles = [4, 5, 6];\n        break;\n      case 8:\n        immediateMovableTiles = [4, 9, 12];\n        columnMovableTiles = [0, 4, 12];\n        rowMovableTiles = [9, 10, 11];\n        break;\n      case 9:\n        immediateMovableTiles = [5, 8, 10, 13];\n        columnMovableTiles = [1, 5, 13];\n        rowMovableTiles = [8, 10, 11];\n        break;\n      case 10:\n        immediateMovableTiles = [6, 9, 11, 14];\n        columnMovableTiles = [2, 6, 14];\n        rowMovableTiles = [8, 9, 11];\n        break;\n      case 11:\n        immediateMovableTiles = [7, 10, 15];\n        columnMovableTiles = [3, 7, 15];\n        rowMovableTiles = [8, 9, 10];\n        break;\n      case 12:\n        immediateMovableTiles = [8, 13];\n        columnMovableTiles = [0, 4, 8];\n        rowMovableTiles = [13, 14, 15];\n        break;\n      case 13:\n        immediateMovableTiles = [9, 12, 14];\n        columnMovableTiles = [1, 5, 9];\n        rowMovableTiles = [12, 14, 15];\n        break;\n      case 14:\n        immediateMovableTiles = [10, 13, 15];\n        columnMovableTiles = [2, 6, 10];\n        rowMovableTiles = [12, 13, 15];\n        break;\n      case 15:\n        immediateMovableTiles = [11, 14];\n        columnMovableTiles = [3, 7, 11];\n        rowMovableTiles = [12, 13, 14];\n        break;\n    }\n    return {\n      immediateMovableTiles: immediateMovableTiles,\n      columnMovableTiles: columnMovableTiles,\n      rowMovableTiles: rowMovableTiles,\n    };\n  }\n\n  setMovableTiles() {\n    const movableTiles = this.detectMovableTiles();\n\n    this.boardState.forEach((tile) => {\n      if (movableTiles.immediateMovableTiles.includes(tile.position)) {\n        tile.setImmediateMovable(true);\n      } else {\n        tile.setImmediateMovable(false);\n      }\n      if (movableTiles.columnMovableTiles.includes(tile.position)) {\n        tile.setRowMovable(true);\n      } else {\n        tile.setRowMovable(false);\n      }\n      if (movableTiles.rowMovableTiles.includes(tile.position)) {\n        tile.setColumnMovable(true);\n      } else {\n        tile.setColumnMovable(false);\n      }\n    });\n  }\n\n  complexIntendToMove(tileHovered, tf) {\n    const emptyTile = this.boardState.find((tile) => tile.number === 0);\n    const emptyRowNumber = emptyTile.coordinates[0];\n    const emptyColNumber = emptyTile.coordinates[1];\n    const rowNumber = tileHovered.coordinates[0];\n    const colNumber = tileHovered.coordinates[1];\n\n    if (rowNumber === emptyRowNumber) {\n      if (colNumber > emptyColNumber) {\n        const tilesToMove = this.boardState.filter(\n          (tile) =>\n            tile.columnMovable &&\n            tile.coordinates[1] > emptyColNumber &&\n            tile.coordinates[1] <= colNumber\n        );\n        tilesToMove.forEach((t) => t.setIntendToMove(tf));\n      } else {\n        const tilesToMove = this.boardState.filter(\n          (tile) =>\n            tile.columnMovable &&\n            tile.coordinates[1] < emptyColNumber &&\n            tile.coordinates[1] >= colNumber\n        );\n        tilesToMove.forEach((t) => t.setIntendToMove(tf));\n      }\n    } else {\n      if (rowNumber > emptyRowNumber) {\n        const tilesToMove = this.boardState.filter(\n          (tile) =>\n            tile.rowMovable &&\n            tile.coordinates[0] > emptyRowNumber &&\n            tile.coordinates[0] <= rowNumber\n        );\n        tilesToMove.forEach((t) => t.setIntendToMove(tf));\n      } else {\n        const tilesToMove = this.boardState.filter(\n          (tile) =>\n            tile.rowMovable &&\n            tile.coordinates[0] < emptyRowNumber &&\n            tile.coordinates[0] >= rowNumber\n        );\n        tilesToMove.forEach((t) => t.setIntendToMove(tf));\n      }\n    }\n    this.setMovableTiles();\n  }\n}\n","/home/alynux/GitHub/fifteen-puzzle/src/components/Game.tsx",[],"/home/alynux/GitHub/fifteen-puzzle/src/components/Grid.tsx",[],"/home/alynux/GitHub/fifteen-puzzle/src/components/GridRow.tsx",[],"/home/alynux/GitHub/fifteen-puzzle/src/components/GridSquare.tsx",["45"],"import React, { useState } from \"react\";\n\nconst gridSquareStyle: React.CSSProperties = {\n  display: \"flex\",\n  flexDirection: \"column\",\n  justifyContent: \"center\",\n  textAlign: \"center\",\n  width: \"75px\",\n  height: \"75px\",\n  boxShadow: \"1px 1px 5px purple\",\n  backgroundColor: \"#98c2d0\",\n  color: \"white\",\n  fontFamily: \"sans-serif\",\n  fontSize: \"18px\",\n};\n\nconst gridSquareHoverStyle: React.CSSProperties = {\n  display: \"flex\",\n  flexDirection: \"column\",\n  justifyContent: \"center\",\n  textAlign: \"center\",\n  width: \"75px\",\n  height: \"75px\",\n  boxShadow: \"1px 1px 5px violet\",\n  border: \"none\",\n  backgroundColor: \"#cdeafb\",\n  color: \"white\",\n  fontFamily: \"sans-serif\",\n  fontSize: \"18px\",\n};\n\nconst gridSquareMovableStyle: React.CSSProperties = {\n  display: \"flex\",\n  flexDirection: \"column\",\n  justifyContent: \"center\",\n  textAlign: \"center\",\n  width: \"75px\",\n  height: \"75px\",\n  border: \"none\",\n  boxShadow: \"1px 1px 5px purple\",\n  backgroundColor: \"#b0ddf8\",\n  color: \"white\",\n  fontFamily: \"sans-serif\",\n  fontSize: \"18px\",\n};\n\nexport type GridSquareData = {\n  tile: any;\n  mutableGame: any;\n  setGameState: any;\n};\n\nconst GridSquare = ({ tile, mutableGame, setGameState }: GridSquareData) => {\n  const [intendToMove, setIntendToMove] = useState(false);\n\n  const immediateMove = () => {\n    // Function for moving tiles that are immediately adjacent to the empty tile\n    setIntendToMove(false);\n    mutableGame.board.immediateMove(tile);\n    setGameState([...mutableGame.board.boardState]);\n  };\n\n  const complexMove = () => {\n    // Function for moving tiles involving pushing more than one block\n    setIntendToMove(false);\n    mutableGame.board.complexMove(tile);\n    setGameState([...mutableGame.board.boardState]);\n  };\n\n  const hoverHighlight = (tile: any, tf: boolean) => {\n    // Function for highlighting tiles that would move upon hover\n    // mutableGame.board.complexIntendToMove(tile, tf);\n    // setGameState([...mutableGame.board.boardState]);\n  };\n\n  if (tile.number === 0) {\n    return <div style={gridSquareStyle}></div>;\n  } else if (tile.immediateMovable || tile.columnMovable || tile.rowMovable) {\n    return (\n      <button\n        onClick={tile.immediateMovable ? immediateMove : complexMove}\n        style={intendToMove ? gridSquareHoverStyle : gridSquareMovableStyle}\n        onMouseEnter={() => setIntendToMove(true)}\n        onMouseLeave={() => setIntendToMove(false)}\n      >\n        {tile.number}\n      </button>\n    );\n  } else {\n    return (\n      <div style={gridSquareStyle}>\n        <p>{tile.number}</p>\n      </div>\n    );\n  }\n};\n\nexport default GridSquare;\n",{"ruleId":"46","replacedBy":"47"},{"ruleId":"48","replacedBy":"49"},{"ruleId":"50","severity":1,"message":"51","line":18,"column":25,"nodeType":"52","messageId":"53","endLine":18,"endColumn":27},{"ruleId":"54","severity":1,"message":"55","line":114,"column":5,"nodeType":"56","messageId":"57","endLine":195,"endColumn":6},{"ruleId":"58","severity":1,"message":"59","line":70,"column":9,"nodeType":"60","messageId":"61","endLine":70,"endColumn":23},"no-native-reassign",["62"],"no-negated-in-lhs",["63"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","@typescript-eslint/no-unused-vars","'hoverHighlight' is assigned a value but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]